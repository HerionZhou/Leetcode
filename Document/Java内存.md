### 1.Java内存区域

线程共享：堆、方法区（包括运行时常量池）

线程私有：虚拟机栈、本地方法栈、程序计数器

Java1.8之后将方法区放在本地内存中，称为元空间。

### 2.程序计数器

1.字节码解释器工作通过改变程序计数器的值来选取下一条需要执行的字节码指令，分支、循环、条件、线程恢复等操作都需要程序计数器。

2.为了线程切换后能恢复到正确的执行位置，每个线程都有一个程序计数器，相互独立，这个内存区域成为“线程私有”。

程序计数器是唯一不会出现OutOfMemoryError的内存区域，随线程创建而创建，随线程结束而死亡。

### 3.Java虚拟机栈

虚拟机栈是线程私有的，生命周期与程序计数器一样，随线程创建而创建，随线程结束而死亡。

Java内存分为栈内存和堆内存，其中栈内存就是虚拟机栈。虚拟机栈包括局部变量表、操作数栈和常量池引用。Java方法在执行的时候会创建一个栈帧保存局部变量表、操作数栈和常量池引用，方法调用到执行结束对应栈帧在虚拟机栈入栈出栈。

StackOverFlowError：虚拟机栈的内存大小不允许扩展，则当线程请求栈的深度超过当前虚拟机栈的最大深度，会抛出此错误。

OutOfMemoryError：虚拟机栈的内存大小可以扩展，当动态扩展栈时无法申请到需要的内存空间，会抛出此错误。

### 4.本地方法栈

跟虚拟机栈差不都，是为本地方法服务。

### 5.堆

##### 定义

堆是JVM管理的最大一块内存，是线程共享的一块内存区域，在虚拟机启动时创建。唯一功能是存放对象实例，几乎所有对象实例和数组都由堆分配内存。

几乎：jdk1.7之后启用了逃逸分析，如果一个对象没有被返回或未被外面使用（没有逃逸出去），则可直接在栈上分配内存。

##### GC堆

堆是垃圾收集器管理的主要区域，所以也叫GC堆，因为现在的垃圾收集器都是分代管理，堆分为老年代，新生代。

jdk8以前分为老年代，新生代，永生代；jdk8之后永生代（方法区）被移除了，改为元空间，使用直接内存。

##### 对象内存分配流程

对象先被分配到Eden区，再一次垃圾回收后，如果还存活，会进入survivor0或s1中，并且对象年龄增加1，当年龄增加到一定程度，会进入老年代。

##### 异常

OutOfMemoryError，分为两种情况：

1.当虚拟机花费大量时间回收垃圾并且只能回收到很少的堆空间时，会抛出异常。

2.当创建新的对象但没有足够的堆空间，会抛出异常。与物理内存无关，与配置的内存大小有关。

### 6.方法区

方法区是线程共享的内存区域，主要存储类信息、常亮、静态变量等。方法区也叫永久代。

##### 为什么jdk1.8之后用元空间替代方法区

1.元空间使用直接内存，受系统内存大小的限制，内存溢出的可能性小。

2.元空间存储类的元数据，能加载的类变多了。

### 7.运行时常量池

运行时常量池是方法区的一部分。class文件中的常量池会在类加载后放入这个区域。

jdk1.7之前字符串常量池在运行时常量池中，方法区的实现为永久代。

jdk1.7字符串常量池放在了堆内存中。

jdk1.8之后字符串常量池在堆内存中，方法区用元空间替代，运行时常量池还在方法区，不过通过元空间实现，使用直接内存。

### 8.直接内存

直接内存不是虚拟机运行时数据区的一部分，也不是虚拟机规范定义的内存区域，但也被频繁使用，也会抛出OutOfMemoryError异常。

jdk1.4时引入了NIO类，引入了一个基于通道和缓冲区的I/O方法，可以直接用native方法分配堆外内存，通过堆内的DirectByteBuffer对象作为堆外内存的引用进行操作。可以提高性能，不用在堆内存和堆外内存频繁拷贝数据。

### 9.对象创建过程

类加载检查--分配内存--初始化零值--设置对象头--执行init方法
[TOC]

### 1.JVM内存分配和回收

Java自动内存管理主要针对对象的内存分配和对象的内存回收，最核心的功能是堆内存中的对象内存的分配和回收。

Java堆内存是垃圾回收管理的主要区域，所以也叫GC堆。从垃圾回收的角度，由于现在收集器基本采用分代垃圾收集算法，所以堆可细分为新生代和老年代，新生代又可分为Eden区，From Survivor，To Survivor空间。

对象先在Eden区分配内存，在经历过一次新生代垃圾回收后，如果对象还存活，则进入From或To区，并且年龄加1，当年龄增加到一定程度，晋升到老年代中。

堆内存常见分配策略：对象优先在Eden区分配、大对象直接进入老年代、长期存活的对象进入老年代。

##### 1.对象优先在Eden区分配

大多数情况下，对象优先在Eden区分配内存，当Eden区没有足够空间时，会发起一次新生代垃圾回收，之后发现新生代放不下新对象，通过分配担保机制，将新生代中的对象转移到老年代中。

##### 2.大对象直接进入老年代

大对象是需要连续内存空间的对象，比如字符串，数组等。

这样做是避免因分配担保机制带来的复制降低效率。

##### 3.长期存活的对象进入老年代

每经历过一次新生代垃圾回收后，如果对象存活，则年龄加1，超过阈值（默认15）则进入老年代。

### 2.动态年龄计算

遍历对象时，按照年龄从小到大对其占用空间进行积累，当积累的某个年龄的对象大小超过survivor的一半时，取这个年龄跟阈值中更小的值作为新阈值。

### 3.垃圾回收分类

针对Hotspot VM，GC只有两种：

##### 1.部分收集

新生代收集：只针对新生代进行垃圾收集。

老年代收集：只针对老年代进行垃圾收集。

混合收集：对整个新生代和部分老年代进行垃圾收集。

##### 2.整堆收集

收集整个Java堆内存和方法区（永久代）。

### 4.对象是否死亡

##### 1.引用计数法

给对象添加一个引用计数器，每当有一个地方引用它，计数器加1；引用失效，计数器减1。

实现简单，效率高，但是无法解决对象之间循环引用的问题。

##### 2.可达性分析算法

通过一系列成为GC Roots的对象作为起点，向下搜索，结点走过的路径成为引用链，当一个对象没有与任何一条引用链相连的话，则对象不可用。

**不可达的对象并非“非死不可”**

两次标记。

可达性分析中不可达的对象被第一次标记并且进行一次筛选，筛选条件是看对象是否有必要执行finalize方法。当对象没有覆盖finalize方法或finalize方法已经被虚拟机调用时，视为没有必要执行。

被判定为需要执行finalize的对象，被放入队列中进行二次标记，除非这个对象与引用链上的任何一个对象建立关联，否则就回收。

 **可作为GC Roots的对象：**

虚拟机栈中引用的对象

本地方法栈中引用的对象

方法区中常量引用的对象

方法区中类静态属性引用的对象

所有被同步锁持有的对象

##### 3.引用

强引用、软引用、弱引用、虚引用。

**强引用**

大部分引用实例都是强引用，GC收集器不会回收，如果内存空间不足，会抛出异常。

**软引用**

如果内存足够，不会回收，如果内存不够，会回收内存。

**弱引用**

垃圾回收时，一旦发现了只有弱引用的对象，不管内存是否充足，都会回收。

**虚引用**

形同虚设，如果一个对象只有虚引用，跟没有任何引用一样，任何时候都有可能被回收。

##### 4.判断常量是废弃常量

常量池中的对象没有被引用。

##### 5.判断类是无用的类

满足三个条件才是无用的类：

类的所有实例被回收

加载该类的ClassLoader被回收

该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

### 5.垃圾收集算法

##### 1.标记-清除

先标记出所有不需要回收的对象，标记完成后统一回收掉所有未标记的对象。

效率低，回收后产生大量不连续的碎片。

##### 2.标记-复制

将内存分为大小相同的两块，每次使用一块。当一块的内存使用完后，将还存活的对象复制到另一块去，然后把这一块全清理掉。

##### 3.标记-整理

标记出不需要回收的对象，让这些对象移动到一端，再清理掉剩下的内存。

##### 4.分代收集算法

新生代中，每次收集都有大量对象死去，可以选择标记-复制算法，而老年代对象存活的几率比较高，而且没有分配担保机制，可以选择标记-清除或标记-整理算法。

### 6.垃圾收集器

Serial收集器、ParNew收集器、Paralell Scavenge收集器、CMS收集器、G1收集器。

##### 1.Serial收集器

串行收集器，是最基本的收集器。是一个单线程收集器，当启动垃圾收集线程时，必须暂停其他所有的线程，直到收集结束。

新生代采用标记-复制算法，老年代采用标记-整理算法。

适用于运行在Client模式下的虚拟机。

##### 2.ParNew收集器

Serial收集器的多线程版。除了Serial外，只有ParNew收集器可以与CMS收集器配合工作。

适用于运行在Server模式下的虚拟机。

##### 3.Paralell Scavenge收集器

多线程收集器，跟ParNew收集器差不多。

关注吞吐量。吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值。

##### 4.CMS收集器

以获取最短回收停顿时间为目标的收集器。CMS收集器是Hotspot虚拟机第一款真正意义上的并发收集器，第一次实现了用户进程和垃圾回收进程同时工作。

采用标记-清除算法，运行过程分为四个步骤：

1.初始标记：暂停其他进程，记录直接与root相连的对象。

2.并发标记：同时开启用户线程和垃圾收集线程，记录可达对象。由于用户线程会不断更新引用域，垃圾收集线程不能保证可达性分析的实时性，所以这个阶段会记录发生更新的地方。

3.重新标记：暂停其他进程，处理修正并发标记时由于用户线程更新引用域变动的部分对象的标记记录。这个阶段停留时间比初始标记长，但比并发标记的时间短。

4.并发清除：同时开启用户线程和垃圾收集线程，对未标记的区域进行清除。

优点是可以并发，低停顿，缺点是收集完会产生不连续碎片、对cpu资源敏感、无法处理浮动垃圾。

##### 5.G1收集器

面向服务器的垃圾收集器。

**特点**

并行与并发：G1能充分利用CPU、多核环境的硬件优势，使用多个CPU来缩短停顿时间。

分代收集：保留了分代的概念。

空间整合：整体看是基于标记-整理算法，部分看是基于标记-复制算法。

可预测的停顿：

**步骤**

初始标记、并发标记、最终标记、筛选回收。

G1收集器维护一个优先列表，根据允许的收集时间，选择回收价值最大的区域。

##### 6.ZGC收集器

Java11推出的收集器。
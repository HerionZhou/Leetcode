[TOC]

### 1.Java内存区域

线程共享：堆、方法区（包括运行时常量池）

线程私有：虚拟机栈、本地方法栈、程序计数器

Java1.8之后将方法区放在本地内存中，称为元空间。

### 2.程序计数器

1.字节码解释器工作通过改变程序计数器的值来选取下一条需要执行的字节码指令，分支、循环、条件、线程恢复等操作都需要程序计数器。

2.为了线程切换后能恢复到正确的执行位置，每个线程都有一个程序计数器，相互独立，这个内存区域成为“线程私有”。

程序计数器是唯一不会出现OutOfMemoryError的内存区域，随线程创建而创建，随线程结束而死亡。

### 3.Java虚拟机栈

虚拟机栈是线程私有的，生命周期与程序计数器一样，随线程创建而创建，随线程结束而死亡。

Java内存分为栈内存和堆内存，其中栈内存就是虚拟机栈。虚拟机栈包括局部变量表、操作数栈和常量池引用。Java方法在执行的时候会创建一个栈帧保存局部变量表、操作数栈和常量池引用，方法调用到执行结束对应栈帧在虚拟机栈入栈出栈。

StackOverFlowError：虚拟机栈的内存大小不允许扩展，则当线程请求栈的深度超过当前虚拟机栈的最大深度，会抛出此错误。

OutOfMemoryError：虚拟机栈的内存大小可以扩展，当动态扩展栈时无法申请到需要的内存空间，会抛出此错误。

### 4.本地方法栈

跟虚拟机栈差不都，是为本地方法服务。Hotspot中将虚拟机栈和本地方法栈合并。

### 5.堆

##### 定义

堆是JVM管理的最大一块内存，是线程共享的一块内存区域，在虚拟机启动时创建。唯一功能是存放对象实例，几乎所有对象实例和数组都由堆分配内存。

几乎：jdk1.7之后启用了逃逸分析，如果一个对象没有被返回或未被外面使用（没有逃逸出去），则可直接在栈上分配内存。

##### GC堆

堆是垃圾收集器管理的主要区域，所以也叫GC堆，因为现在的垃圾收集器都是分代管理，堆分为老年代，新生代。

jdk8以前分为老年代，新生代，永生代；jdk8之后永生代（方法区）被移除了，改为元空间，使用直接内存。

##### 对象内存分配流程

对象先被分配到Eden区，再一次垃圾回收后，如果还存活，会进入survivor0或s1中，并且对象年龄增加1，当年龄增加到一定程度，会进入老年代。

##### 异常

OutOfMemoryError，分为两种情况：

1.当虚拟机花费大量时间回收垃圾并且只能回收到很少的堆空间时，会抛出异常。

2.当创建新的对象但没有足够的堆空间，会抛出异常。与物理内存无关，与配置的内存大小有关。

### 6.方法区

方法区是线程共享的内存区域，主要存储类信息、常量、静态变量等。方法区也叫永久代。

##### 为什么jdk1.8之后用元空间替代方法区

1.元空间使用直接内存，受系统内存大小的限制，内存溢出的可能性小。

2.元空间存储类的元数据，能加载的类变多了。

### 7.运行时常量池

运行时常量池是方法区的一部分。class文件中的常量池会在类加载后放入这个区域。

jdk1.7之前字符串常量池在运行时常量池中，方法区的实现为永久代。

jdk1.7字符串常量池放在了堆内存中。

jdk1.8之后字符串常量池在堆内存中，方法区用元空间替代，运行时常量池还在方法区，不过通过元空间实现，使用直接内存。

### 8.直接内存

直接内存不是虚拟机运行时数据区的一部分，也不是虚拟机规范定义的内存区域，但也被频繁使用，也会抛出OutOfMemoryError异常。

jdk1.4时引入了NIO类，引入了一个基于通道和缓冲区的I/O方法，可以直接用native方法分配堆外内存，通过堆内的DirectByteBuffer对象作为堆外内存的引用进行操作。可以提高性能，不用在堆内存和堆外内存频繁拷贝数据。

### 9.对象创建过程

类加载检查--分配内存--初始化零值--设置对象头--执行init方法

##### 1.类加载检查

虚拟机遇到new指令时，首先去检查指令的参数是否能在常量池中定位到这个类的符号引用，并检查这个符号引用代表的类是否加载、解释、初始化过。如果没有，则执行相应的类加载过程。

##### 2.分配内存

虚拟机为新生对象分配内存，所需内存在类加载后就确定。

###### 分配方式

两种分配内存方法：指针碰撞、空闲列表。选择哪种分配方式取决于java堆是否规整，java堆是否规整又取决于GC处理器采用哪种算法（标记-清除、标记-规整/压缩）。

指针碰撞：java堆内存规整，用过的内存在一边，没用的在一边，中间一个分界值指针，创建新对象只需要向没用过的内存一边移动对象内存大小的位置即可。

空闲列表：java堆内存不规整，虚拟机维护一个列表，记录哪些内存块可用，分配时找一块足够大的内存块分配给对象实例，最后更新列表记录。

###### 并发问题

内存分配需要保证线程安全。

两种方式保证线程安全：

1.CAS+失败重试：CAS是乐观锁的实现，乐观锁指假设没有冲突，只在更新数据时检查冲突，如果失败就重试。虚拟机通过CAS+失败重试保证更新操作的原子性。

2.TLAB：为每一个线程在eden区分配一块内存，JVM给线程中的对象分配内存时，先在TLAB分配，当对象大于TLAB中剩余内存或TLAB内存耗尽时，再采用CAS+失败重试进行内存分配。

##### 3.初始化零值

虚拟机将分配到的内存空间都初始化为零值（不包括对象头）。保证了对象的实例字段在不赋初始值就可直接使用。

##### 4.设置对象头

虚拟机对对象进行必要的设置，例如是哪个类的实例、对象的哈希码、对象的GC分代年龄等信息。

##### 5.执行init方法

上面工作完成后，对虚拟机来说，新的对象已经生成了，但从java程序来看，对象创建才刚刚开始，因为对象的字段都为零值，执行init方法初始化对象后，才算真正可用的对象创建完毕。

### 10.对象的内存布局

对象在内存中的布局分为三部分：对象头，实例数据、对齐填充。

##### 1.对象头

对象头包括两部分：一部分是对象自身的数据，另一部分是类型指针，指向类元数据，虚拟机通过这个指针来确定对象是哪个类的实例。

##### 2.实例数据

实例数据是对象真正储存的有效信息，程序中定义的各种字段内容。

##### 3.对齐填充

占位作用。虚拟机要求对象起始地址必须是8字节的整数倍，所以对象的内存大小也是8字节的整数倍，用对齐填充补全。

### 11.对象的访问定位

对象访问方式：使用句柄、直接指针。

##### 1.使用句柄

Java堆内存划出一块内存作为句柄池，reference中存的是句柄地址，句柄中包含的对象实例数据与类型数据的地址。

好处是稳定，在对象被修改时reference不需要修改，只需要改变句柄中实例对象的指针。

##### 2.直接指针

reference中存的是对象的地址。

好处是速度快，节省了一次指针定位的开销。

### 12.包装类缓存技术

Byte、Short、Integer、Long使用了缓存技术，范围-128~127

Character使用了缓存技术，范围0~127

```java
Integer i4 = new Integer(40);
Integer i5 = new Integer(40);
Integer i6 = new Integer(0);
```

 i4 == i5 + i6，因为+这个操作符不适用于 Integer 对象，首先 i5 和 i6 进行自动拆箱操作，进行数值相加，即 i4 == 40。然后 Integer 对象无法与数值进行直接比较，所以 i4 自动拆箱转为 int 值 40，最终这条语句转为 40 == 40 进行数值比较。
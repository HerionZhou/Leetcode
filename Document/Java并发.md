### 1.进程

进程就是程序的一次执行过程，是系统运行程序的基本单位，是资源分配的最小单位。系统运行一个程序即从进程创建运行到消亡的过程。

在Java中，运行main函数时启动一个JVM进程，而main函数所在的线程就是这个进程的主线程。

### 2.线程

线程是CPU调度的基本单位，一个进程中可以有多个线程，共享进程的堆和方法区的资源（线程共享），但每个线程有自己独立的虚拟机栈、本地方法栈、程序计数器（线程私有）。

### 3.程序计数器为什么私有

字节码解释器通过程序计数器来判断需要执行的下一条指令，多线程下的程序计数器主要用来记录线程执行的位置，从而当线程被切换回来时恢复线程运行位置。

执行本地方法时，程序计数器记录的是undefined地址，只有执行java方法时，程序计数器记录的才是下一条指令的地址。

程序计数器私有主要是为了线程切换后能恢复到正确的执行位置。

### 4.虚拟机栈和本地方法栈为什么私有

虚拟机栈：java方法执行是会创建一个栈帧存储局部变量表、操作数栈、常量池引用等信息。从方法调用到执行结束的过程对应栈帧在虚拟机栈的入栈出栈操作。

本地方法栈：跟虚拟机栈类似，是为本地方法服务。Hotspot虚拟机中本地方法栈跟虚拟机栈合并。

虚拟机栈和本地方法栈私有主要是保证线程中的局部变量不被外界访问到。

### 5.并发、并行

并发是同一时间段内，可以执行多个任务。

并行是单位时间内，可以执行多个任务。

### 6.为什么使用多线程

线程是程序运行的最小单位，是轻量级进程，线程间的切换和调度成本小于进程。cpu多核时多个线程可以同时运行，减少线程切换时的开销。

单核：cpu单核时，使用多线程的作用是提高cpu和I/O设备的利用率，当使用单线程时，会有一个设备空闲，利用率低；使用多线程理想状态下设备的利用率是100%。

多核：cpu多核时，使用多线程的作用主要是提高cpu的利用率。

### 7.线程的生命周期

初始状态、运行状态、阻塞状态、等待状态、超时等待状态、终止状态。

##### 1.初始状态

线程被构建，但还没有调用start()方法。

##### 2.运行状态

Java线程将操作系统的运行状态和就绪状态统称为运行状态。

##### 3.阻塞状态

线程由于等待进入synchronized块或synchronized方法而阻塞。获取到锁结束。

##### 4.等待状态

线程进入等待状态，表示当前线程需要等待其他线程做出一些特定动作（通知或中断）。

当执行wait()后，线程进入等待状态，需要其他线程通知notify()才能返回。

##### 5.超时等待状态

不同于等待状态，可在指定时间自行返回。

##### 6.终止状态

线程执行完毕。

### 8.上下文切换

线程数大于cpu数，而一个cpu核心任何时刻只能被一个线程调用，为了让所有线程都可以执行，采用时间片轮转的方式分配cpu资源。当一个线程的时间片用完后会进入就绪状态，将cpu资源给其他线程使用，这个过程就是上下文切换。

任务从保存到再加载的过程就是一次上下文切换。

### 9.死锁

##### 1.四个条件

互斥条件、请求并保持条件、不可剥夺条件、循环等待条件。

##### 2.策略

**预防死锁**

程序运行前预防发生死锁。

破坏互斥条件。（一般不）

破坏请求并保持条件。

破坏不可剥夺条件。

破坏循环等待条件。

**避免死锁**

程序运行中避免发生死锁。

使用银行家算法等算法。如果一个状态下有一个推进顺序能使所有进程都顺利获取到资源并执行，则是安全状态。

**死锁检测死锁恢复**

不试图阻止死锁，发生死锁后进行恢复。

环路等待发生死锁。

E：资源总量，A：资源剩余量，C：每个进程拥有资源量，D：每个进程请求资源量。

死锁恢复：杀死进程，回滚恢复，抢占恢复。

**鸵鸟策略**

发生死锁什么也不做。解决死锁问题代价很高，不处理死锁问题能获得更高的性能。

### 10.sleep()和wait()

sleep()不会释放锁，wait()会释放锁。

两者都可以暂停线程的执行。sleep()用来暂停线程，wait()用于线程通信和交互。

wait()被调用后，线程不会自动苏醒，除非有其他线程调用notify()或notifyAll()。sleep()调用后，线程会自动苏醒。

### 11.调用start()会自动执行run()，为何不直接调用run()

new一个Thread，线程会进入初始状态。调用start()方法，会启动一个线程并使线程进入就绪状态，当分配到时间片时就会执行。strat()会执行线程的准备工作，并自动执行run()，这是真正的多线程。

而直接执行run()方法，会把run()方法作为main线程下的普通方法去执行，不是多线程。

调用start()会启动线程并进入就绪状态，直接调用run()不会用多线程执行。
[TOC]

### 1.事务

ACID特性：

##### 1.原子性

事务是最小执行单位，要么全完成，要么全失败。

通过undo log（回滚日志）保证原子性。

##### 2.一致性

执行事务后，数据保持一致。

保证了原子性、隔离性、持久性，一致性才能得到保障。

##### 3.隔离性

并发访问数据库时，事务之间不会相互干扰，各并发事务之间数据库是独立的。

通过锁机制、MVCC保证隔离性。

##### 4.持久性

事务提交后，对数据库中数据的改变是永久性的，即时数据库故障崩溃也不会有任何影响。

通过redo log（重做日志）保证持久性。

### 2.并发事务带来的问题

##### 1.脏读

一个事务读取到了另一个事务未提交的数据，这种数据称为脏数据，对脏数据做的操作是不正确的。

##### 2.不可重复读

一个事务在两次读取数据之间，因为第二个事务对数据进行修改，而导致第一个事务两次读取到的数据不一样。

##### 3.幻读

一个事务读取一些数据，接着另一个事务插入了一些数据，第一个事务第二次读时的数据与第一次不一样。

##### 4.脏读、不可重复读、幻读区别

脏读是读到了其他事务未提交的数据，不可重复读是读到了其他事务已提交的数据。

不可重复读是读取同一个数据项，幻读是一批数据。不可重复读的重点是修改，幻读的重点在于新增或者删除。

解决不可重复读只需要锁住对应记录；解决幻读需要锁住对应记录和可能的间隙。

##### 5.丢失修改

两个事务分别读取到同一数据，第一个事务修改数据后，第二个事务也修改了数据，会造成第一个事务的修改结果丢失。

### 3.事务的隔离级别

##### 1.未提交读

啥也解决不了。

##### 2.已提交读RC

一个事务提交后才能被另一个事务读取。

解决脏读，会发生不可重复读、幻读。

大部分数据库默认隔离级别是已提交读。

##### 3.可重复读RR

事务多次读取会返回第一次读取的快照。

解决脏读、不可重复读，会发生幻读。InnoDB通过NKL锁解决幻读。

InnoDB默认可重复读。

##### 4.串行化

写加X锁，读加S锁，当冲突的时候，后续的事务必须等前一个事务执行完才能执行。

事务100%隔离，解决脏读、不可重复读、幻读问题。

### 4.MyISAM、InnoDB

MySQL5.5之前，MyISAM引擎是默认存储引擎，5.5之后InnoDB是默认存储引擎。

##### 1.是否支持行级锁

MyISAM只支持表级锁；InnoDB支持行级锁和表级锁，默认行级锁。所以说InnoDB在并发下性能比MyISAM好。

##### 2.是否支持事务

MyISAM不支持事务；InnoDB提供事务支持，就有commit和rollback事务的能力。

##### 3.是否支持外键

MyISAM不支持外键；InnoDB支持外键。

##### 4.是否支持异常崩溃后的安全恢复

MyISAM不支持；InnoDB支持安全恢复，依赖redo log（重做日志）保证事务的持久性，undo log（回滚日志）保证事务的原子性。

InnoDB通过锁机制，MVCC保证事务的隔离性。

##### 5.是否支持MVCC

MyISAM不支持MVCC；InnoDB支持MVCC。

### 5.MVCC

多版本并发控制，指在已提交读和可重复度的隔离级别下的事务对于SELECT操作会访问版本链中记录的过程。

##### 1.版本链

在InnoDB中，记录有两个隐藏列：trx_id和roll_pointer。

trx_id：存储每次对记录进行修改的事务id。

roll_pointer：回滚指针，对记录修改时，会把老版本写入undo log中，回滚指针存了一个指针，指向记录上一个版本的位置。

##### 2.ReadView（视图）

ReadView中主要存储着当前活跃着的读写事务，就是begin了还没commit的事务，通过这个列表可以判断记录的某个版本是否对当前事务可见。

已提交读隔离级别下的事务在每次查询开始是生成一个新的ReadView；可重复读隔离级别的事务则在第一次读生成一个ReadView，之后的读都复用这个ReadView。

可重复读会产生幻读问题。InnoDB通过NKL锁解决幻读问题。

InnoDB默认机制是可重复读。

### 6.锁机制

##### 1.表级锁，行级锁

表级锁：锁定粒度最大的一种锁，对整个表加锁，实现简单，资源消耗少，不会产生死锁，并发效率低，MyISAM和InnoDB都支持表级锁。

行级锁：锁定粒度最小的一种锁，只针对操作行加锁，开销大，会产生死锁，并发效率高，是InnoDB的默认锁。

##### 2.锁的类型

**InnoDB存在两个行级别的锁：**

1.S Lock共享锁：允许事务读一行数据。

2.X Lock排它锁：允许数据删除或修改一行数据。

共享锁之间可以并存，但共享锁与排它锁不能并存。

**表级别的锁，意向锁：**

1.IS Lock意向共享锁：事务想要获取一张表中某几行的共享锁。

2.IX Lock意向排它锁：事务想要获取一张表中某几行的排他锁。

**一致性非锁定读**

可重复读，已提交读

**一致性锁定读**

显式加锁

select ... for update加X行锁

select ... lock in share mode加S行锁

##### 3.锁的算法

RL记录锁：只锁当前记录

GL间隙锁：不包含当前记录

NKL临键锁：包含当前记录

### 7.加锁分析

select：因为有多版本并发控制（MVCC），读的是快照，不加锁。

delect，update：

##### 1.RC已提交读

（1）id是主键：RL锁，当前记录加锁

（2）id是唯一索引：加两个RL锁，一个是唯一索引中的记录，一个是主键索引中的记录

（3）id是普通索引（不唯一）：加两个RL锁，一个是索引中所有对应的记录，一个是主键索引中所有对应的记录。

（4）id没有索引：全表扫描，所有记录加锁

##### 2.RR可重复读

（1）id是主键：RL锁，当前记录加锁

（2）id是唯一索引：加两个RL锁，一个是唯一索引中的记录，一个是主键索引中的记录

（3）id是普通索引（不唯一）：对索引中所有记录和主键索引中对应的记录加RL锁，对可能出现的间隙加GAP锁（GL）

（4）id没有索引：全表扫描，所有记录加RL锁，所有间隙加GAP锁

### 8.索引实现

##### 1.MyISAM

B+树

主键索引的叶子结点存储的是指向记录的地址。

辅助索引也是指向地址，但索引的key可以重复。

##### 2.InnoDB

B+树，数据文件本身就是索引文件

主键索引的叶子结点存储的就是数据记录，索引的key是表的主键，这种索引也叫聚集索引。所以必须有主键，没有指定则自动选择可以唯一标识数据的列作为主键，如果没有则生成一个隐含字段，占6个字节，长整型，自增。

辅助索引的叶子结点存储的是数据的主键，所以说辅助索引也需要主键索引来实现。

##### 3.为什么不用hash表

hash索引不支持顺序查找和范围查找；hash冲突问题。

### 9.索引

**最左前缀**匹配原则。

##### 1.聚集索引

指索引文件和数据文件一起存放的索引。

主键索引，一个表一般只有一个聚集索引。

**优点：**查询速度快，定位到叶子结点也就定位到了数据。

**缺点：**无序数据不友好；删除、插入数据需要更新索引，修改的代价大。

##### 2.非聚集索引

指索引文件和数据文件分开存放的索引。

**优点：**更新代价小。

**缺点：**无序数据不友好；查找到主键还需通过主键索引查找数据（需要回表查询）。

普通索引、唯一索引、联合索引（复合索引，覆盖索引）。

**唯一索引：**唯一索引的属性列不能重复，但可以为空，一张表可以创建多个唯一索引，目的大部分为了数据列的唯一性。

**普通索引：**为了快速查询数据。

**前缀索引：**用于字符串类型的数据，取字符串前几位创建索引，相比普通索引建立的数据更小。

**全文索引：**为了检索数据库中大文件的关键词，主要是搜索引擎数据库使用。MySQL5.6之后InnoDB也支持全文索引。

**联合索引：**多个字段组成的索引。遵循最左前缀原则。

### 10.覆盖索引（不回表查询）

如果一个索引包含所有查询字段的值，成为覆盖索引。

主键索引查询主键时就是覆盖索引。

### 11.创建索引的注意事项

##### 1.选择合适的字段创建索引

（1）不为null的字段

（2）被频繁查询的字段

（3）频繁需要排序的字段

（4）作为条件查询的字段

（5）频繁用于连接的字段

##### 2.避免频繁被更新的字段创建索引

更新索引的成本很大。

##### 3.用联合索引代替单列索引

索引需要存储在硬盘上，一个索引就是一个B+树，如果字段数很大，单列索引很多要占较大的硬盘空间。使用联合索引可以节省磁盘空间，还可以提高更新数据的效率。

##### 4.避免冗余索引

索引的功能相同，能够命中（a，b）的索引也能命中（a）的索引，则（a）就是冗余索引。

扩展索引而不是新建索引。

##### 5.对字符串类型使用前缀索引

占用更小的空间。

### 12.添加索引代码

##### 1.主键索引

```sql
ALTER TABLE 'table_name' ADD PRIMARY KEY ('colum');
```

##### 2.唯一索引

```sql
ALTER TABLE 'table_name' ADD UNIQUE ('colum');
```

##### 3.普通索引

```sql
ALTER TABLE 'table_name' ADD INDEX index_name ('colum');
```

##### 4.联合索引

```sql
ALTER TABLE 'table_name' ADD INDEX index_name ('colum1', 'colum2');
```

##### 5.全文索引

```sql
ALTER TABLE 'table_name' ADD FULLTEXT ('colum');
```

### 13.MySQL架构

分为server层和存储引擎层

#### 1.server层

##### 1.连接器

身份认证和权限相关的功能，负责用户登录数据库，校验密码成功后，会到权限表查询中查询用户的权限，之后在这个连接中的权限逻辑判断都会依据这个结果。

##### 2.查询缓存

主要用来储存查询过得SELECT语句和查询结果。MySQL8.0被移除。

执行查询语句时，首先校验这个语句是否执行过，以key-value的形式存储在内存中。如果缓存key被命中，则直接返回结果；如果未命中，则进行下一步。

##### 3.分析器

词法分析：提取关键字，例如SELECT、表名、字段名、查询条件等。

语法分析：检查SQL语句是否正确，是否符合SQL语法。

##### 4.优化器

优化SQL语句，用优化器认为最优的执行方案执行。比如多个索引时如何选择索引，多表查询如何选择查询顺序。

[优化器介绍](https://blog.csdn.net/dev666/article/details/81532222)

##### 5.执行器

开始执行，首先校验用户有没有权限，如果没有权限，则返回错误；有权限则调用存储引擎的接口，返回查询结果。

#### 2.存储引擎

负责数据的存储和读取，MySQL支持InnoDB、MyISAM等多个存储引擎，默认InnoDB。

#### 3.语句分析

##### 1.查询语句

先检查用户有没有权限，没有权限返回错误；有权限，MySQL8.0之前会查询缓存，如果key命中，则返回数据，如果没有命中，则进入分析器

通过分析器进行词法检查，提取关键要素，例如SELECT、表名、字段名、查询条件等；之后进行语法检查，检查SQL语句是否符合规范，有没有错误，如果没有，进入优化器。

根据优化器选择最优的方案，进入执行器。

执行前先进行权限校验，如果没权限则返回错误；有权限则调用存储引擎的接口，返回结果。

##### 2.更新语句

执行更新前与查询语句一样。

得到查询结果，进行修改，调用存储引擎接口，InnoDB将数据保存在内存中，同时记录redo log（重做记录），此时redo log进入prepare状态，之后告诉执行器可以提交。

执行器收到通知后记录bin log（归档日志），然后再调用存储引擎，修改redo log为提交状态。

##### 3.为何更新需要两个日志

binlog是MySQL自有的，只能用来进行归档，不支持安全恢复；InnoDB的redo log是用来支持事务的，支持安全恢复。

##### 4.为何redo log有prepare状态

反证：

1.先提交redo log，后写binlog：若提交redo log后数据库异常崩溃，则恢复后通过redo log恢复数据，但由于binlog没有这条数据，后续备需要回滚的时候会丢失一条数据。

2.先写binlog，后提交redo log：若写入binlog后数据库异常崩溃，则恢复后通过redo log恢复数据，由于没有这条记录，则不会恢复这条数据。

使用redo log的两阶段提交可以保持数据一致性。

##### 5.redo log prepare状态，binlog写入后崩溃

1.判断redo log是否完整，完整则立即提交

2.如果redo log是prepare状态，则判断binlog是否完整，完整则提交，不完整则回滚事务。


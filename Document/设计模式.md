[TOC]

### 1.设计模式的类型

##### 1.构建型模式5

提供了一种在创建对象的同时隐藏逻辑的方法，而不是直接使用new运算符来实例化对象。

- 工厂模式
- 抽象工厂模式
- 单例模式
- 原型模式
- 建造者模式

##### 2.结构性模式7

- 适配器模式
- 桥接模式
- 组合模式
- 装饰器模式
- 外观模式
- 享元模式
- 代理模式

##### 3.行为型模式11

- 责任链模式
- 命令模式
- 解释器模式
- 迭代器模式
- 中介者模式
- 备忘录模式
- 观察者模式
- 状态模式
- 策略模式
- 模版模式
- 访问者模式

### 2.设计模式的六大原则

##### 1.开闭原则

对修改封闭，对扩展开放。

##### 2.单一职责原则

一个类只做一件事。

##### 3.里氏替换原则

子类可以完全替换父类。

##### 4.依赖倒置原则

细节应该依赖于抽象。

##### 5.迪米特法则

最少知道原则，一个类不应该知道自己操作的类的细节。

##### 6.接口隔离原则

客户端不应该依赖不需要的接口，如果有冗余的空实现，应该将接口拆分，让实现类只依赖自己需要的接口方法。

### 3.构建型模式

关注类的创建。

##### 1.工厂模式Factory

将创建对象的过程封装起来，只需要知道对象的名称就可以通过工厂创建对象。

**优点：**想创建对象，只需要知道名称即可；扩展性高，增加一个类只需要扩展工厂；类的构造方法复杂，只需要修改工厂，不需要修改业务代码。

**缺点：**每增加一个类，就需要增加一个具体类和对象实现工厂，使系统中的类成倍增加，增加系统的复杂度。

##### 2.抽象工厂模式AbstractFactory

创建一个超级工厂来创建其他工厂，是工厂的工厂。

**优点：**增加新工厂方便，替换工厂只需要修改一行代码。

**缺点：**扩展工厂类的功能，则影响所有的具体工厂类。

##### 3.单例模式Singleton

全局只需要一个实例时，可以使用单例模式。

**优点：**避免重复创建对象，节约空间并提升效率。

**缺点：**没有接口，不能继承。

**双重校验锁为什么使用volatile：**

因为jvm内创建对象和赋值是两个操作，并且jvm会对java指令进行优化，可能发生一种情况：jvm为实例分配了空间直接赋值给instance，这个线程释放了锁；另一个线程getInstance时因为赋值了所以直接返回，但此时可能还没有进行初始化。

volatile有避免指令重排的功能，用volatile修饰可以避免这种错误情况。

也可以使用静态内部类来避免这种情况，因为类加载对线程是互斥的，天然线程安全。

##### 4.原型模式Prototype

实现Cloneable接口，重写clone()方法

**优点：**new一个新对象需要非常多的数据准备，可以使用原型模式，避免构造函数的约束。

**缺点：**需要实现Cloneable接口

##### 5.建造者模式Builder

适用于创建过程稳定，但配置复杂的类。

通过在类的内部建立一个静态类Builder来通过链式调用构造对象。构造函数是私有的。

类的构造函数是私有的，参数是Builder，通过链式调用设置Builder对象的参数，将参数传给类。

Builder中每个成员变量一个方法，返回值是Builder，设置变量值后返回Builder。

### 4.结构型模式

关注类和对象的组合。

##### 1.适配器模式Adapter

将一个类的接口转换成另外一个接口，将原本由于接口不兼容而不能一起工作的类可以一起工作。

**优点：**可以让无关的两个类一起运行，提高了类的复用

**缺点：**使用适配器太多会让系统复杂，应尽量避免使用适配器模式。

##### 2.桥接模式Bridge

面向两个或多个同等级的接口。将抽象部分与实现部分分离，二者相互独立，实现抽象化与实现化解耦。

**优点：**抽象与实现分离；扩展能力好，不会出现继承方式的类爆炸问题。

**缺点：**增加设计难度。

##### 3.组合模式Composite

又叫部分整体模式，把一组相似的对象看做单一对象，关系是树形关系的各类相似的对象，可以使用组合模式。

透明方式：在组合模式的类中声明所有管理子对象的方法，具备完全一致的接口，违背了接口隔离原则。

安全方式：在组合模式的类中只声明所有类都需要的接口，不同的接口在子对象中实现。

**优点：**调用简单，节点自由增加。不用去写重复的代码。

**缺点：**违反依赖倒置原则。

##### 4.装饰器模式Decorator

两种功能：增强现有功能和添加新功能。

在不修改原结构的情况下，增强现有功能和添加新功能，装饰器类把原来的类包装起来。

**InputStream用到了装饰器模式。**

**增强：**装饰器也实现原有接口，不增加新方法。

**增加：**创建新功能需要的接口，这个接口继承原接口，实现类重写新方法。

**优点：**装饰器是继承的一个扩展，不需要写大量子类，防止类爆炸。装饰类和被装饰类相互独立，不会耦合。

**缺点：**容易造成大量相似的类。

##### 5.外观模式Facade

外观模式就是封装的思想，将内部隐藏起来，只提供可以访问的接口。

MVC中Controller可以看做外观类，Model和View通过Controller交互，减少耦合。

**优点：**简洁。

**缺点：**不符合开闭原则。

##### 6.享元模式Flyweight

减少创建的对象，用来减少内存占用和提高性能。享元模式就是共享对象。

##### 7.代理模式Proxy

一个类代表另一个类，用作打印日志，权限控制等。

装饰器模式为了增强功能或添加功能，代理模式为了加以控制。

```java
Proxy.newProxyInstance(classLoader, Interfaces, h)
classLoader:被代理的类的classLoader
Interfaces:被代理的类的接口
h:在h中实现动态代理
```

动态代理节省代码量，只需要写需要控制的方法；静态代理需要把每一个方法重写。

### 5.行为型模式

关注类和类之间的交互与合作。

##### 1.责任链模式Chain

为请求创建了一个接受者的链。用于职责相同，程度不同的类。只需要将请求发送到责任链上即可，不需要关心具体处理流程。将请求发送者与请求的处理者解耦。

**优点：**降低耦合度；扩展性强；灵活性强；责任进行分担。

**缺点：**可能导致请求到达责任链的末端而不被处理；责任链过长，涉及众多处理对象，影响性能。

##### 2.命令模式Command

把请求封装成对象，各种命令都隐藏在命令类中。通过execute()方法调用方法，可以进行方法排队、撤销等处理。

**优点：**降低系统的耦合度，对行为请求者和行为实现者解耦。

扩展性强，增加删除命令方便，不会影响其他类。

**缺点：**创建大量命令类，增加系统复杂性。

##### 3.解释器模式Interpreter

实现表达式接口，解释特定的上下文；进行自定义语法。

**正则表达式是解释器。**

不可拆分的最小单元称为终结表达式，其他的称为非终结表达式。

**优点：**扩展性好，可以实现简单语法。

**缺点：**可用的场景少，难以维护，实现非常复杂。

##### 4.迭代器模式Iterator

提供一种方法顺序访问对象中的元素，但不暴露对象的内部细节。

通过next()方法获取数据，通过hasNext()方法判断是否还有数据。Java中内置了Iterator接口。

##### 5.中介者模式Mediator

定义一个中介类封装对象之间的交互，将原有对象解耦，将类之间多对多的关系简化为一对多、多对一。

**优点：**对象间解耦，降低类的复杂度。

**缺点：**中介者会很复杂，难以维护。

##### 6.备忘录模式Memento

在不破坏封装的条件下，通过Memento对象保存对象的某个状态，以便在适当的时候进行恢复。

**优点：**为用户提供了一种可以恢复状态的机制；实现了信息的封装，用户不需要关心细节。

**缺点：**如果类的成员变量过多，会占用大量资源。

##### 7.观察者模式Observer

定义对象间一个一对多的依赖关系，当一个对象的状态发生改变时，所有依赖它的对象都会得到通知并自动更新。

Java内置了Observer接口和Observable接口，用synchronized修饰，是线程安全的。

##### 8.状态模式

类的状态不同会有不同的行为，通过多态替换if...else...和switch...case...。将特定的状态相关的行为封装到状态类中。

**优点：**把与状态有关的行为封装到状态类中，改变状态对象就能改变行为。可以让多个对象共享一个状态对象。

**缺点：**增加类和对象的个数，增加系统复杂性。

##### 9.策略模式Strategy

殊途同归，不同的方法都可以完成一件事，通过策略模式可以让用户在不同状态下选择不同的策略。

**优点：**策略可以切换，替换了条件判断。

**缺点：**增加策略类，增加了系统复杂性；策略类需要对外暴露。

##### 状态模式和策略模式

策略模式，程序只要选择一种策略就可以完成某件事，每种策略都可以完成。

状态模式，完成不同的事需要切换不同的状态，每个状态完成的事不同，所有状态组合才能完成某件事。

##### 10.模版方法模式Template

模版是一个抽象类，在抽象类中定义方法的骨架，子类可以在不改变方法结构的情况下重写某些步骤。

不希望子类重写模版的方法，用final修饰；要求子类重写模版中的方法，用abstract修饰。

**优点：**封装不变部分，扩展可变部分。行为由父类控制，子类实现。

**缺点：**不同实现需要不同的子类。

##### 11.访问者模式Visitor

将数据结构与数据操作分离；在被访问的类里添加一个对外提供接待访问者的接口。

**优点：**符合单一职责原则；扩展性好。

**缺点：**类中元素需要对访问者公布细节；具体元素变更困难，需要修改访问者的接口；违反依赖倒置原则，依赖了具体类。

用重写方法的动态分派特性将重载方法也模拟成动态分派。

##### 分派

方法调用的一个概念。

对于重写方法：调用父类还是子类的方法，会根据参数运行时的实际类型来决定，称为动态分派。

对于重载方法：调用哪个方法由方法签名中声明的参数类型决定，在编译器确定，称为静态分派。

单分派：重载方法和重写方法只有一个是动态分派。

多分派：重载方法和重写方法都是动态分派。

Java是单分派。使用访问者模式需要用重写方法来将重载方法模拟成动态分派。